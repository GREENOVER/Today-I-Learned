## TIL (Today I Learned)

### 11월 19일 (목)

- #### 학습내용
  오늘은 KVO와 노티피케이션에 대해 강의를 들었다. 그전에 Step1을 진행하며 나온 질문에 대해 애매했던 부분을 캠퍼들과 야곰의 설명을 들으며 확실히 요점을 정리하였다. 프로퍼티 기본값을 주느냐 아니면 이니셜라이저로 초기화 하느냐에 대한것이다. 
    - 인스턴스 프로퍼티 초기화 값에 대해
      내가 생각하고 정리한바로는 프로퍼티에 바로 초기값을 주어 생성하는것은 호출 시 초기값을 지정해주지 않아도 되는 편리함이 있다. 아래와 같이 생성하고 호출한다. 
      ```swift
      class Green {
      var age: Int = 100
      }
      let green: Green = Green()
      ```
반면 이니셜라이저를 통해서는 아래와 같이 코드로 나타내고 호출 시 초기값을 줄 수 있다.
      ```swift
class Green {
	var age: Int
	init(age: Int) {
		self.age = age
	}
}
let green: Green = Green(100)
      ```
이렇게 이니셜라이저를 통해 정의하고 호출 시 초기값을 전달하는 방식의 장점은 추후 유지보수나 데이터의 값을 변경할 때 타입 자체를 건드리지 않아도된다는 점이다. 호출하는 소스파일에서만 변경하면 된다. 정의된 타입을 왠만하면 건들지 않는것이 좋다. 그런데 위의 이니셜라이저를 통해 정의하고 호출하는 부분에 있어서도 만약 인스턴스가 여러개일때 초기값이 일괄적으로 바뀐다면 일일히 수정해줘야되서 번거로움이 있을것이다. 이에 더 편리할것 같은 방법은 아래 코드와 같다.
      ```swift
var initialAge: Int = 100
let green: Green = Green(initialAge)
      ```
이렇게 한다면 인스턴스가 다중이더라도 코드에서 100이라는 데이터 하나의 정보만 변경하면 됨으로 유지보수 시 더 깔끔하고 편리할 수가 있다.
추가로, 강의 후 찾아보던 관점이 위 이니셜라이저 시 self.age = age에서 var age가 있고 파라미터 age의 명이 동일한데 어떤 age인지 구분하는것이 명확하지 않아서 고민해보았다. 그부분은 self.age로 해당 파라미터의 age를 위 변수 age에 넣어주는것이다. 여기서 Step1/2에 대해 적용할 수 있는 방법을 고민을 해보았다. 쥬스 메이커 타입 정의 시 이니셜라이저를 통해 과일들을 지정해주고 뷰컨트롤러 스위프트 소스파일에서 인스턴스 생성 시 초기값을 주어 생성 할 수도 있겠다고 생각했다. 그런데 그렇게된다면 Step1에서 타입정의 시 과일재고들은 읽기전용으로 설정하는 부분에 있어 위배가 될것 같다. 이 부분은 다른 부분에서 적용 시켜볼 예정이다. 그래도 둘의 차이를 조금 명확하게 느꼈다.

    - KVO / Notification
두가지의 개념을 선행으로 학습하려했으나 개념자체가 어렵게 느껴졌었고 코드를 통해 설명을 보니 예습할때 많이 벅찼다. 강의를 통해 그래도 둘의 차이점과 개념에 대해 어느정도 뚜렷해졌다. 
    1. Notification
인스턴스 간에는 통신이 필요할때가 있다. 예를들어 이번 프로젝트에서도 과일재고가 변한다던지 하는 부분에서 값이란 데이터가 변한다. 만약 다른 두 인스턴스가 과일재고를 동일하게 소유하고 소진한다면 통신이 필요할 것이다. 그 인스턴스간의 통신을 해주는 매개체라고 생각한다. 인스턴스간 직접적인 연관이 있다면 메서드를 호출하고 리턴하여 통신할 수 도 있지만, 직접적인 연관이 없는 큰 프로젝트를 진행 시 자주 사용될 것 같다. 우선 2가지의 역할이 있다.
 -> Notification : 매개체가 되어 알려주는것
 -> Observing : 매개체를 지켜보는것 (옵저버: 인스턴스)
스위프트에서 제공하는 Notification을 하기 위해 일종의 유투브같은 Notification center가 있다. 이 센터에서 각 여러 매개체가 채널이 될 수가 있을것이며, 인스턴스들은 해당 센터에서 원하는 매개체(채널)에 등록하여 변화가 있을때 알림을 받아 각자의 기능을 할 수가 있다.
흐름으로 나눠본다면 아래와 같을것이다.
 -1) Notification center 등록 (채널 등 설정)
 -2) Observer 등록 (인스턴스가 원하는 채널과 연결하여 알림 시 하는일을 정의함)
 -3) 채널에서 어떠한 변화 시 post로 옵저버에게 알려줌
 -4) 옵저버는 알림을 receive하여 기능을 수행함.
야곰이 방송국에 빗대어 강의를 해주어서 이해가 정말 많이 되었다!

    2. KVO
Key-Value-Observing
위 방식과의 차이점은 주체이다. 위의 알림을 주고 전달하는 일련의 매개체에는 Notification center가 있다. 그러나 해당 방식은 주체가 옵저버와 관측하는 대상이라고 생각한다. 이것도 야곰의 애정도에 관해 표현해준것에 쉬운 이해를 하였다. KVO도 일대일부터 일대다까지 가능하다. 
이렇게 어떠한 인스턴스간의 변화에 대한 통신에 대해 개념을 조금 잡으며 알아보았다. 해당 개념을 쥬스 메이커 프로젝트에서 앞서말한 과일 재고에 대해 연동시켜볼 수도 있겠다고 생각했다. Step2와 Step3 사이에서 메인화면과 재고 수정하는 화면에서 인스턴스를 달리하여 해당 인스턴스간 통신을 한뒤 재고 수량에 대해 주고 받는 방법을 적용해볼수도 있을것같다. 그전에 개념만 알뿐이지 정확하게 어떻게 코드로 사용하는지 학습해봐야겠다.

- #### 문제점 / 고민한 점
Step 1을 진행하며 접근제어에 대해 학습하며 읽기전용으로 효과적으로 적용시켜보려고 찾아보며 고민했다. 처음 프로젝트 진행 시 접근제어 부분에 대해 잘 알지 못하였다. 수업을 통해 캠퍼들과 소통하며 Step1에서 읽기전용으로 과일재고를 지정하는것에 분명 이유가 있겠다 싶었지만 적용을 하지 못하였다. 예상대로 리뷰 코멘트에 접근 제어에 대해 알아볼 필요가 있을것 같다는 답변을 받아 완벽하게는 아니더라도 알아보려했다. 
어떻게해야 모델에서 읽기전용으로 과일재고를 타 소스파일이나 모듈에서 변경할 수 없으며 대신 다른 소스 파일에서 읽고 할 수 있을까에 대해 고민을 하였다.

- #### 고민점에 대한 해결노력
해당 고민을 해결하고자 접근제어 레벨에 관해 학습을 하였다. 스위프트에서 접근제어 단계는 크게 아래와 같이 5단계가 있다. 
 1) private
  : 가장 제한적으로 접근할 수 있는 범위는 해당 정의된 메서드 내에서 가능 합니다. 즉 해당 중괄호 안에서만 접근할 수 있습니다.
 2)  fileprivate
  : private 다음으로 제한적이지만 해당 스위프트 파일에서만 접근이 가능합니다.
 3) internal
  : 기본적인 접근레벨로 접근레벨을 앞에 붙여서 설정하지 않고 생략한다면 다 internal입니다. 내부 소스파일에서 접근 가능합니다.
 4) public
  : 외부모듈에서도 접근이 가능하며 주로 프레임워크를 만들때 사용합니다. 같은 모듈에서만 오버라이드 될 수 있습니다.
 5) open
  : public과 동일하지만 차이점은 외부 모듈에서도 오버라이드 될 수 있습니다. 또한 open 접근제어는 class에서만 사용이 가능합니다.
-. 제한단계 : private > fileprivate > internal > public > open

  추가로, gettet와 setter 연산프로퍼티의 사용과 이니셜라이저에 대해 학습을 해보며 적용해보았다. 처음 읽기전용으로 모델에서 fileprivate로 접근 제어를 주며 과일 재고의 초기 변수를 지정해주고 연산 프로퍼티로 get 부분만 줌으로 인스턴스에서 set은 직접할 수 없고 get을 하도록 구현하였다. 조금 더 학습해보니 private(set)이라는것을 찾았다. 야곰의 코멘트를 토대로 이것과 연산프로퍼티를 주는것과 무슨 차이가 있는지 생각해보았다. getter와 setter에 서로 다른 접근 제어자를 적용할 수 있다는 공통점인데, getter setter 모두 따로 작성하지 않아도 setter를 getter보다 더 제한적으로 설정 할 수 있었다. 즉, setter는 private로 getter는 internal로 접근레벨을 설정할 수가 있다. 애석하게도 getter를 setter보다 더 제한적으로 설정하는것은 불가능하다. 그래서 과일 초기재고를 fileprivate(set) 접근제어로 설정하고 이니셜라이저를 통해 코드를 수정해보니 조금 더 깔끔해지고 추후 유지보수가 이전보다 수월할 것같다.