## TIL (Today I Learned)

### 12ì›” 19ì¼ (ì›”)   

- ### [í•™ìŠµë‚´ìš©] 
   ### RxSwiftë¡œ ì„œë²„ í†µì‹ í•˜ê¸°
    ìš°ì„  ì„œë²„ í†µì‹ ì´ í•„ìš”í•œ í™˜ê²½ì´ ì •ë§ í•„ìˆ˜ì ì´ê³  ë§ì€ë¶„ë“¤ì´ RxSwiftë¥¼ ì‚¬ìš©í•˜ê³  ìˆì„ê±°ì—ìš”.
    ê·¸ë ‡ê¸°ì— ì €ë„ ë‚˜ë¦„ì˜ ë°©ì‹ìœ¼ë¡œ RxSwiftë¥¼ ì‚¬ìš©í•˜ë©´ì„œ ì˜ì§œì—¬ì§„ ì„œë²„ í†µì‹  í…œí”Œë¦¿ì„ ë§Œë“¤ê³  ì‰½ê²Œ ì‚¬ìš©í•´ë³´ë ¤í•©ë‹ˆë‹¤!!   

    ë¨¼ì € ë“¤ì–´ê°€ê¸°ì „ ì‚¬ìš©ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‘ê°€ì§€ì…ë‹ˆë‹¤.
    Alamofireì™€ RxSwift
    Alamofireë¥¼ í†µí•´ ì¡°ê¸ˆ ë” ê°„í¸í•˜ê²Œ ì„œë²„ í†µì‹ ì„ ì‹œí‚µë‹ˆë‹¤.
    Moyaë¥¼ í™œìš©í•˜ì§€ ì•Šì€ ì´ìœ ëŠ” ë„¤íŠ¸ì›Œí¬ ë ˆì´ì–´ë¥¼ ì¶”ìƒí™”í•œê²ƒë¿ì´ë¼ ì´ ë¶€ë¶„ì€ ì§ì ‘ êµ¬í˜„í•˜ë©´ì„œ ì¡°ê¸ˆ ë” ì¥ì ì„ ê°€ì ¸ê°”ìŠµë‹ˆë‹¤.

    ê·¸ëŸ¼ í•œë²ˆ ë³´ì‹œì£ ğŸ¥¸

    ìš°ì„  ê°€ì¥ ë¨¼ì € ë§Œë“¤ì–´ë³¼ê²ƒì¸ ì„œë²„ í†µì‹  ê·œì•½ì„ ì •í•´ë³´ëŠ” Router í”„ë¡œí† ì½œê³¼ í•´ë‹¹ í”„ë¡œí† ì½œì„ ë”°ë¥´ë©´ì„œ ì‹¤ì œ ì„œë²„ í†µì‹ í•˜ëŠ” ì—­í• ì„ ê°€ì§„ RotuerManagerë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.
    ì´ ë‘ê°€ì§€ë¥¼ ë§Œë“¤ê³  ì‹¤ì œ API í†µì‹  ê°ì²´ê¹Œì§€ ë§Œë“¤ì–´ ì‚¬ìš©í•´ë³¼ê»˜ìš”!

    #### Router í”„ë¡œí† ì½œ
    ```swift
    import Alamofire
    import Foundation

    public protocol Router {
      var baseURL: URL { get }
      var path: String { get }
      var method: HTTPMethod { get }
      var headers: [String: String]? { get }
      var task: Task { get }
    }

    public enum Task {
      // ì¶”ê°€ì ì¸ ë°ì´í„° ì—†ëŠ” Request
      case requestPlain

      // Encodable íƒ€ì…ì˜ Bodyë¥¼ ì„¤ì •í•œ Request
      case requestJSONEncodable(Encodable)

      // Encodable íƒ€ì…ì˜ Bodyì™€ custom encoderë¥¼ ì„¤ì •í•œ Request
      case requestCustomJSONEncodable(Encodable, encoder: JSONEncoder)

      // encode ëœ parameterë¥¼ ì„¤ì •í•œ Request
      case requestParameters(parameters: [String: Any], encoding: ParameterEncoding)
    }
    ```
    ìš°ì„  í†µì‹ ì„ í• ë•Œ ë‹¹ì—°íˆ í•„ìš”í•œ ìš”ì†Œë“¤ì¸ URLê³¼ path, í†µì‹  ë°©ë²•, í—¤ë”ì— ë‹´ê¸¸ê²ƒ ê·¸ë¦¬ê³  ê·¸ ì™¸ ë°ì´í„° ìš”ì²­ ì—…ë¬´ì¸ task ì´ 5ê°€ì§€ë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤.
    ì´ë¥¼ í”„ë¡œí† ì½œë¡œ ì§€ì •í•´ì¤ë‹ˆë‹¤.

    ê·¸ ë‹¤ìŒìœ¼ë¡œ í•´ë‹¹ í”„ë¡œí† ì½œì„ ì±„íƒí•´ ì‹¤ì œ í†µì‹ ì„ êµ¬í˜„í•˜ëŠ” RouterManagerë¥¼ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

    #### RouterManager
    ```swift
    import Alamofire
    import Foundation
    import RxSwift

    // MARK: - RouterManager êµ¬í˜„
    public struct RouterManager<T: Router> {
      private let alamorefireSession: Session
      private let interceptor: Interceptor?

      public init(
        alamofireSession: Session = .default,
        interceptor: Interceptor? = nil,
      ) {
        self.alamorefireSession = alamofireSession
        self.interceptor = interceptor
      }

      public func request(router: T) -> Single<Data> {
        return sendRequest(router: router)
        }
      }
    }

    // MARK: - í†µì‹ ì— ì‚¬ìš©ë  Error ê°ì²´
    public struct RouterManagerError: CustomError {
      public var userInfo: [String: Any]?
      public var code: Code
      public var underlying: Error?
      public var errorBody: "ì‘ë‹µ DTO"?

      public enum Code: Int {
        case failedRequest = 0
        case isNotSuccessful = 1
      }

      public init(
        code: RouterManagerError.Code,
        userInfo: [String: Any]? = nil,
        underlying: Error? = nil,
        response: AFDataResponse<Data>? = nil
      ) {
        self.code = code
        self.userInfo = userInfo
        self.underlying = underlying
        self.userInfo?["response"] = response

        if let data = response?.data {
          self.errorBody = try? JSONDecoder().decode("ì‘ë‹µ DTO".self, from: data)
        }
      }
    }

    // MARK: - Custom Error í”„ë¡œí† ì½œ
    public protocol OPGGError: CustomNSError {
      var code: Code { get }
      var userInfo: [String: Any]? { get }
      var underlying: Error? { get }

      associatedtype Code: RawRepresentable where Code.RawValue == Int
    }

    extension OPGGError {
      var errorDomain: String { "\(Self.self)" }
      var errorCode: Int { self.code.rawValue }
      var errorUserInfo: [String: Any]? {

        var userInfo: [String: Any] = self.userInfo ?? [:]

        userInfo["identifier"] = String(reflecting: code)
        userInfo[NSUnderlyingErrorKey] = underlying

        return userInfo
      }
    }

    // MARK: - ì‹¤ì œ RouterManagerì˜ í†µì‹  êµ¬í˜„ë¶€
    public extension RouterManager {
      // Alamofireë¥¼ í†µí•œ ìš”ì²­ ë©”ì„œë“œ
      func sendRequest(router: T) -> Single<Data> {
        return Single.create(subscribe: { single in
          let dataRequest: DataRequest = makeDataRequest(router: router)

          dataRequest
            .responseData { response in
              switch response.result {
              case .success:
                guard let statusCode = response.response?.statusCode else { return }
                let isSuccessful = (200..<300).contains(statusCode)

                if isSuccessful {
                  guard let data = response.data else { return }
                  single(.success(data))
                } else {
                  let error = RouterManagerError(
                    code: .isNotSuccessful,
                    userInfo: ["router": router],
                    response: response
                  )
                  single(.failure(error))
                }

              case let .failure(underlyingError):
                let error = RouterManagerError(
                  code: .failedRequest,
                  userInfo: ["router": router],
                  underlying: underlyingError,
                  response: response
                )
                single(.failure(error))
              }
            }
          return Disposables.create()
        })
      }

      // Routerì˜ taskì— ë”°ë¼ request ë°ì´í„° ìƒì„± ë©”ì„œë“œ
      private func makeDataRequest(router: Router) -> DataRequest {
        switch router.task {
        case .requestPlain:
          return self.alamorefireSession.request(
            "\(router.baseURL)\(router.path)",
            method: router.method,
            headers: HTTPHeaders(headers: router.headers),
            interceptor: interceptor
          )

        case let .requestJSONEncodable(parameters):
          let encodable = AnyEncodable(parameters)

          return self.alamorefireSession.request(
            "\(router.baseURL)\(router.path)",
            method: router.method,
            parameters: encodable,
            encoder: JSONParameterEncoder.default,
            headers: HTTPHeaders(headers: router.headers),
            interceptor: interceptor
          )

        case let .requestCustomJSONEncodable(parameters, encoder):
          let encodable = AnyEncodable(parameters)

          return self.alamorefireSession.request(
            "\(router.baseURL)\(router.path)",
            method: router.method,
            parameters: encodable,
            encoder: .json(encoder: encoder),
            headers: HTTPHeaders(headers: router.headers),
            interceptor: interceptor
          )

        case let .requestParameters(parameters, encoding):
          return self.alamorefireSession.request(
            "\(router.baseURL)\(router.path)",
            method: router.method,
            parameters: parameters,
            encoding: encoding,
            headers: HTTPHeaders(headers: router.headers),
            interceptor: interceptor
          )
        }
      }

    // MARK: - Header ì´ˆê¸°í™”
    fileprivate extension HTTPHeaders {
      init?(headers: [String: String]?) {
        guard let headers = headers else {
          return nil
        }

        self.init(headers)
      }
    }

    // MARK: - AnyEncodable ê°ì²´
    fileprivate struct AnyEncodable: Encodable {
      private let encodable: Encodable

      public init(_ encodable: Encodable) {
        self.encodable = encodable
      }

      func encode(to encoder: Encoder) throws {
        try encodable.encode(to: encoder)
      }
    }
    ```
    ë³´ì‹œë©´ ìš°ì„  RouterManager ì •ì˜ë¶€ì—ëŠ” sessionê³¼ interceptorë¥¼ ê°€ì§‘ë‹ˆë‹¤.
    request ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê²Œ ë˜ë©´ ì‹¤ì œ í†µì‹ ì„ ìœ„í•œ requestë¥¼ ë³´ë‚´ê³  ì´ì— ëŒ€í•œ ë‚´ë¶€ ì²˜ë¦¬ê°€ ì´ë¤„ì ¸ìˆìŠµë‹ˆë‹¤.
    ì—ëŸ¬ì— ëŒ€í•´ì„œë„ ì»¤ìŠ¤í…€í•œ ì—ëŸ¬ í”„ë¡œí† ì½œì„ ë§Œë“¤ê³  ì´ë¥¼ ì±„íƒí•´ ì •í˜•í™”ë˜ê³  ì„œë¹„ìŠ¤ì— ë§ëŠ” ì—ëŸ¬ í˜•íƒœë¥¼ ë§Œë“­ë‹ˆë‹¤.

    ì´ì œ ì‹¤ì œë¡œ í†µì‹ ì„ ì‹œì¼œë³´ì£ !
    extensioní•˜ì—¬ ì¡°ê¸ˆ ë” ê°€ë…ì„±ì„ ë†’ì—¬ì¤¬ì–´ìš”.

    sendRequestë¥¼ í†µí•´ êµ¬í˜„ì„ í•´ì£¼ëŠ”ë° ì—¬ê¸°ì„œ ì¸ìë¡œ ë§Œë“  ë¼ìš°í„° íƒ€ì…ì„ ë°›ì•„ Single<Data> íƒ€ì…ìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
    ì¦‰, í†µì‹ ì„ ì‹œí‚¤ê³  ì´ì— ëŒ€í•œ ë°ì´í„°ë¥¼ í•´ë‹¹ Observableì„ êµ¬ë…í•˜ëŠ”ê³³ì— ì „ë‹¬í•˜ëŠ” ì…ˆì´ì£ .
    Single.createë¡œ ìŠ¤íŠ¸ë¦¼ì„ ë§Œë“­ë‹ˆë‹¤.
    ì´ì— ë˜ ë°ì´í„° ë¦¬í€˜ìŠ¤íŠ¸ íƒ€ì…ì„ ë§Œë“¤ê¸° ìœ„í•´ ë³„ë„ ë©”ì„œë“œì¸ makeDataRequestì— ë¼ìš°í„°ë¥¼ ì „ë‹¬í•´ ìƒì„±í•©ë‹ˆë‹¤.
    ê·¸ëŸ¼ Routerì˜ task íƒ€ì…ì— ë”°ë¼ ì•Œë§ì€ í˜•íƒœì˜ DataRequest ê°ì²´ë¥¼ ë§Œë“¤ì–´ ë°˜í™˜í•´ì£¼ì£ .
    ì´ ê°ì²´ë¡œ responseDataë¥¼ í•˜ì—¬ í†µì‹  ë°›ì€ ê²°ê³¼ë¥¼ ê°€ì§€ê³  ì„±ê³µì¼ ì‹œ singleì˜ successì— dataë¥¼ ë‹´ì•„ ë„˜ê²¨ì£¼ë©´ ë˜ê³  ì•„ë‹ˆë©´ failureì— errorë¥¼ ë‹´ì•„ ë„˜ê²¨ì£¼ê²Œë©ë‹ˆë‹¤.

    ì´ëŸ¼ ìš°ì„  í†µì‹  êµ¬í˜„ì€ ëì´ë‚˜ìš”!
    ì´ì œ ì‹¤ì œë¡œ ì„œë¹„ìŠ¤ì— ë§ê²Œ Routerë¥¼ ì§€ì •í•˜ê³  í†µì‹ ì‹œí‚¬ ìˆ˜ ìˆëŠ” ì„œë¹„ìŠ¤ë¥¼ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤ğŸ•ºğŸ»

    #### ì‹¤ì œ í†µì‹  API
    ```swift
    import Alamofire
    import Foundation

    public enum NetworkAPI {
      case getUser(name: String)
    }

    extension NetworkAPI: Router {
      public var baseURL: URL {
        return URL(string: "ì„œë²„ URL Host ì£¼ì†Œ")!
      }

      public var path: String {
        switch self {
        case let .getUser(name):
          return "/\(name)"
        }
      }

      public var method: HTTPMethod {
        switch self {
        case .getUSer:
          return .get
        }
      }

      public var task: Task {
        switch self {
        case .getUSer:
          return .requestPlain
        }
      }

      public var headers: [String: String]? {
        return ["Content-type": "application/json"]
      }
    }
    ```
    ì´ê±´ ê°ì í”„ë¡œì íŠ¸ ì„œë²„ ì…ë§›ì— ë§ê²Œ ì ìš©í•˜ê³  ì¶”ê°€í•˜ë©´ ë©ë‹ˆë‹¤.
    ìš°ì„  ê°€ìƒì˜ APIë¥¼ ë§Œë“¤ì–´ë´¤ëŠ”ë°ìš”.
    ì—¬ê¸°ì„œëŠ” ìœ ì €ì˜ ì •ë³´ë§Œ ë°›ì•„ì˜¤ëŠ” ë‹¨ìˆœí•œ API ìš”ì²­ë§Œ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
    Router í”„ë¡œí† ì½œì„ ìƒì†í•˜ì—¬ baseURLì„ host URLë¡œ ì§€ì •í•´ì¤ë‹ˆë‹¤.
    pathì—ëŠ” ìœ„ NetworkAPI ì—´ê±°ê°’ì— ë”°ë¼ ì›í•˜ëŠ” pathë¥¼ ì§€ì •í•˜ì£ .
    methodì™€ taskë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤.
    headersëŠ” ë‹¤ë¥¸ê²Œ ìˆìœ¼ë©´ ìˆ˜ì •í•˜ì—¬ ë¶„ê¸°ì²˜ë¦¬í•´ ì‚¬ìš©í•´ë„ ë˜ì§€ë§Œ ì™ ë§Œí•˜ë©´ í•´ë‹¹ í˜•ì‹ì´ë‹ˆ ìš°ì„  ì €ë ‡ê²Œ ê°€ì ¸ê°”ìŠµë‹ˆë‹¤!

    ê·¸ ë‹¤ìŒìœ¼ë¡œ ì‹¤ì œ ì´ APIë¥¼ ê°€ì§€ê³  í†µì‹ ì„ ì‹œí‚¬ Serviceë¥¼ ë§Œë“¤ì–´ë³¼ê»˜ìš”!

    #### ì„œë²„ í†µì‹  Service ê°ì²´
    ```swift
    public struct UserService {
      public let fetchUser: (_ name: String) -> Observable<Summoner>

      private init(fetchUser: @escaping (_ name: String) -> Observable<User>) {
        self.fetchUser = fetchUser
      }
    }

    extension UserService {
      public static let live = Self(
        fetchUser: { name in
          return RouterManager<NerworkAPI>
            .init()
            .request(router: .fetchUser(name: name))
            .map({ data -> "í†µì‹ í•  DTO" in
              do {
                return try JSONDecoder()
                  .decode(
                    "í†µì‹ í•  DTO".self,
                    from: data
                  )
              } catch {
                throw UserServiceError(
                  code: .decodeFailed,
                  userInfo: ["data": data],
                  underlying: error
                )
              }
            })
            .map { return $0.user }
            .asObservable()
        }
      }
    )}

    public struct UserServiceError: OPGGError {
      public var code: Code
      public var userInfo: [String: Any]?
      public var underlying: Error?

      public enum Code: Int {
        case decodeFailed = 0
      }

      public init(
        code: OPGGServiceError.Code,
        userInfo: [String: Any]? = nil,
        underlying: Error? = nil
      ) {
        self.code = code
        self.userInfo = userInfo
        self.underlying = underlying
      }
    }
    ```
    classì¼ í•„ìš”ëŠ” ë”±íˆ ì—†ì–´ structë¡œ ë§Œë“­ë‹ˆë‹¤.
    í•´ë‹¹ ì„œë¹„ìŠ¤ë¥¼ í†µí•´ ì°”ëŸ¬ì¤„ API ì¢…ë¥˜ë¥¼ í”„ë¡œí¼í‹°ë¡œ ê°€ì ¸ê°€ìš”.
    ì¦‰ NetworkAPIë¥¼ í†µí•´ í†µì‹ í•˜ë©´ Observable<Data>ê°€ ë°©ì¶œë˜ê³  ì´ì— ë”°ë¼ mapì„ ëŒë ¤ dataë¥¼ ì‚¬ìš©í• ê³³ì— ë§ëŠ” DTOì˜ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë³´ë‚´ì£¼ê²Œë©ë‹ˆë‹¤.
    ì—¬ê¸°ì„œ í•  ì¼ì€ API ì°Œë¥´ê³  ë””ì½”ë”©ì„ ì‹œì¼œ ì„±ê³µ ì‹œ ë””ì½”ë”©ëœ ë°ì´í„°ì—ì„œ ì›í•˜ëŠ” ê°’ì„ ë°˜í™˜í•˜ê³  ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ë¥¼ ë˜ì ¸ì£¼ê²Œ ë©ë‹ˆë‹¤.

    ì—¬ê¸°ê¹Œì§€í•˜ë©´ ë‹¤ ì™”ì–´ìš”!
    ì´ì œ ì‹¤ì œë¡œ ì´ UserServiceë¥¼ í˜¸ì¶œí•˜ëŠ” êµ¬í˜„ë¶€ë¥¼ ë³´ê² ìŠµë‹ˆë‹¤ğŸ™Œ

    #### ì‹¤ì œ ì½”ë“œ ë¡œì§ì—ì„œ UserService í˜¸ì¶œ

    VCë‚˜ ì›í•˜ëŠ” Core ë¡œì§ì—ì„œ í˜¸ì¶œí•´ì£¼ë©´ ë©ë‹ˆë‹¤.
    ```swift
    ...
    let userService: UserService.live
    ...
    userService.fetchUser("GREEN")
      .map { userInfo -> "ì›í•˜ëŠ” í˜•íƒœ" in
        // ì›í•˜ëŠ” ë™ì‘
        // ì£¼ë¡œ userë‚˜ íŠ¹ì • dataì— userInfoë¥¼ ë„£ìŒ
      }
    ...
    ```
    ì´ì œ ì´ë ‡ê²Œ ê°„ë‹¨íˆ userService ê°ì²´ë¥¼ ë§Œë“¤ì–´ ì •í•´ì§„ API í˜¸ì¶œ ë©”ì„œë“œë¥¼ ì°”ëŸ¬ì£¼ê³  ë°˜í™˜ëœ user ë°ì´í„°ë¥¼ ê°€ì§€ê³  ì›í•˜ëŠ” ë¡œì§ì„ êµ¬ì„±ì‹œì¼œì£¼ë©´ ëì…ë‹ˆë‹¤ğŸ˜Š

    #### ë§ˆë¬´ë¦¬

    ì´ë ‡ê²Œ Moyaë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  RxSwiftì™€ Alamofireë¥¼ í†µí•´ ì»¤ìŠ¤í…€í•œ ë„¤íŠ¸ì›Œí¬ í†µì‹  ê°ì²´ë¥¼ ë§Œë“¤ê³  ì‚¬ìš©í•´ë´¤ì–´ìš”ã…ã…
    í‹€ì„ í•œë²ˆ ì •í•´ë‘ë©´ ì–´ëŠê³³ì´ë“  í†µì¼ë˜ê²Œ ì†ì‰½ê²Œ í†µì‹ ì„ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ í¸ë¦¬í•©ë‹ˆë‹¤ğŸ™Œ
