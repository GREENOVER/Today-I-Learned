## TIL (Today I Learned)

### 5ì›” 20ì¼ (ëª©)

- #### [í•™ìŠµë‚´ìš©]
  
  ### ì—°ê²° ë¦¬ìŠ¤íŠ¸ ğŸ§‘ğŸ»â€ğŸ’»
    - ì´ì „ / ë‹¤ìŒì˜ ì˜¬ ê°’ì˜ ì°¸ì¡° ì •ë³´ ê°€ì§€ëŠ” ë°°ì—´ì˜ í˜•íƒœ
    - ë¬¼ë¦¬ì  ìˆœì„œê°€ ìˆœì°¨ì ì´ì§€ ì•ŠìŒ
    - í•œë²ˆì— ì°¾ëŠ” ë°ì´í„°ì— ì ‘ê·¼ ë¶ˆê°€
    - ë°ì´í„° ì‚½ì… ë° ì‚­ì œ ì‹œ ì´ë™ ì—†ì´ ì°¸ì¡° ê°’ ë³€ê²½ë§Œ í•´ì£¼ë©´ë˜ì„œ ë°°ì—´ë³´ë‹¤ ì‰¬ì›€ (ì†ë„ê°€ ë¹ ë¦„)
    - ë…¸ë“œì™€ ë°ì´í„°ë¡œ êµ¬ì„±
    - ë…¸ë“œì—ëŠ” ë‹¤ìŒ ì£¼ì†Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” í¬ì¸í„°ë¥¼ ì§€ë‹˜
    - ê²€ìƒ‰ ì†ë„ê°€ ëŠë¦¬ê³  ì €ì¥ ê³µê°„ íš¨ìœ¨ì„±ì´ ë–¨ì–´ì§
  
  ### Swift ì½”ë“œë¡œ êµ¬í˜„í•˜ê¸° ğŸ“
```swift
import Foundation

// ë…¸ë“œ ì •ì˜, Nodeì˜ ê°’ì¸ valueì™€ ë‹¤ìŒ ë…¸ë“œì˜ ì£¼ì†Œë¥¼ ê°€ì§„ next
class Node<T> {
    var data: T?
    var next: Node?
    
    init(data: T?, next: Node? = nil) {
        self.data = data
        self.next = next
    }
}

// ë…¸ë“œë¥¼ ê´€ë¦¬í•´ì£¼ëŠ” ë‹¨ë°©í–¥ ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°ì²´
struct LinkedList<T: Equatable> {
    var head: Node<T>?
    
    init(head: Node<T>? = nil) {
        self.head = head
    }
    
    // ë§¨ ë’¤ì— ìƒˆë¡œìš´ ë…¸ë“œ ì¶”ê°€ ì‹œ
    mutating func append(_ data: T?) {
        // ë¦¬ìŠ¤íŠ¸ì— ê°’ì´ ì—†ì„ë•Œ ìƒˆë¡­ê²Œ í—¤ë“œ ì§€ì •
        if head == nil {
            head = Node(data: data)
            return
        }
        // ë¦¬ìŠ¤íŠ¸ì— ê°’ì´ ì´ë¯¸ ì¡´ì¬í• ë•Œ ë‹¤ìŒ ë…¸ë“œê°€ ì—†ëŠ”ê³³ê¹Œì§€ ì°¾ì€ ë‹¤ìŒ ë§ˆì§€ë§‰ì— ë°°ì¹˜
        var node = head
        while node?.next != nil {
            node = node?.next
        }
        node?.next = Node(data: data)
    }
    
    // íŠ¹ì • ìœ„ì¹˜ì— ìƒˆë¡œìš´ ë…¸ë“œ ì‚½ì…
    mutating func insert(_ data: T, at index: Int) {
        // ë¦¬ìŠ¤íŠ¸ ê°’ ì—†ì„ë•Œ ìƒˆë¡­ê²Œ í—¤ë“œ ì§€ì •
        if head == nil {
            head = Node(data: data)
            return
        }
        // ì¤‘ê°„ì— ë°ì´í„° ì‚½ì… ì‹œ
        var node = head
        for _ in 0..<(index - 1) {
            if node?.next == nil {
                break
            }
            node = node?.next
        }
        let nextNode = node?.next
        let insertNode = Node(data: data)
        node?.next = insertNode
        insertNode.next = nextNode
    }
    
    // ë§ˆì§€ë§‰ ë°ì´í„° ìš”ì†Œ ì‚­ì œ
    mutating func removeLast() {
        // ë°ì´í„° ì—†ì„ ì‹œ ë¯¸ì‚­ì œ
        if head == nil {
            return
        }
        // ë°ì´í„° 1ê°œì¼ ì‹œ í—¤ë“œ ì‚­ì œ
        if head?.next == nil {
            head = nil
            return
        }
        // ë°ì´í„° ì—¬ëŸ¬ê°œì¼ ì‹œ ë§ˆì§€ë§‰ ìš”ì†Œ ì°¾ì•„ì„œ ì‚­ì œ
        var node = head
        while node?.next?.next != nil {
            node = node?.next
        }
        node?.next = nil
    }
    
    // ì›í•˜ëŠ” ìœ„ì¹˜ ìš”ì†Œ ì‚­ì œ
    mutating func remove(at index: Int) {
        // ë°ì´í„° ì—†ë‹¤ë©´ íƒˆì¶œ
        if head == nil {
            return
        }
        // headë¥¼ ì‚­ì œí• ë•Œ
        if index == 0 {
            head = nil
            return
        }
        // ì‚­ì œí•  ë…¸ë“œì˜ ë‹¤ìŒ ë…¸ë“œë¥¼ ì´ì „ ë…¸ë“œê°€ ì—°ê²°í•˜ê²Œ ë³€ê²½
        var node = head
        for _ in 0..<(index - 1) {
            // ì‚­ì œí•  ë…¸ë“œê°€ ë§¨ ë§ˆì§€ë§‰ ë…¸ë“œì¼ë•Œ ì‚­ì œ
            if node?.next?.next == nil {
                break
            }
            node = node?.next
        }
        node?.next = node?.next?.next
    }
    
    // ì „ì²´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚­ì œ
    mutating func removeAll() {
        head = nil
    }
    
    // ë°ì´í„°ë¡œ ì›í•˜ëŠ” ë…¸ë“œ ì°¾ê¸°
    mutating func search(data: T?) -> Node<T>? {
        // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ nil ë°˜í™˜
        if head == nil {
            return nil
        }
        var node = head
        while node?.next != nil {
            if node?.data == data {
                break
            }
            node = node?.next
        }
        return node
    }
    
    // ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ì‚¬ì´ì¦ˆ ì¸¡ì •
    func size() -> Int {
        var node = head
        if node == nil {
            return 0
        }
        var count = 1
        
        while node?.next != nil {
            node = node?.next
            count += 1
        }
        return count
    }
    
    // ì°¾ëŠ” ë°ì´í„°ê°€ ìˆëŠ”ì§€ì— ëŒ€í•´ íŒë³„
    func contains(_ data: T) -> Bool {
        var node = head
        
        while true {
            if node?.data == data {
                return true
            }
            node = node?.next
            if node?.data == nil {
                return false
            }
        }
    }
    
    // ì—°ê²° ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆëŠ”ì§€ íŒë³„
    var isEmpty: Bool {
        return head == nil
    }
}

var linkList = LinkedList<Int>(head: Node(data: 1, next: nil))
linkList.append(2)
print(linkList.contains(2)) // true
print(linkList.size()) // 2
print(linkList.insert(3, at: 1))
```

ë…¸ë“œì˜ ì œë„¤ë¦­ì— Equatable í”„ë¡œí† ì½œì„ ì±„íƒí•œ ì´ìœ ëŠ” ì´í›„ searchì™€ contains ë©”ì„œë“œì—ì„œ ê°’ì„ ë¹„êµí•´ì£¼ê¸° ìœ„í•´ ì±„íƒí•´ì•¼í•œë‹¤.    

ì‹¤ì œë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í˜„í•´ë³´ë©´ì„œ ëŠê¼ˆë˜ì ì´ ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ê³  ìˆì–´ ì‚­ì œí•˜ê±°ë‚˜ í• ë•Œì—ëŠ” í•´ë‹¹ ë…¸ë“œì˜ ì—°ê²°ì„ ëŠì–´ì£¼ë©´   

ì‹¤ì œë¡œ ì‚­ì œëœê²ƒìœ¼ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.   

ê·¸ë˜ì„œ ì „ì²´ ì‚­ì œ ì‹œì—ë„ í—¤ë“œ ë…¸ë“œë§Œ ì—†ì• ì£¼ë©´ ì „ì²´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì ‘ê·¼í•˜ì§€ ëª»í•¨ìœ¼ë¡œ ì‚­ì œë¼ ë³¼ ìˆ˜ ìˆë‹¤.   

ë°°ì—´ë³´ë‹¤ í•´ë‹¹ ì›í•˜ëŠ” ì¸ë±ìŠ¤ ë…¸ë“œì˜ ì ‘ê·¼ì€ ë¶ˆí¸í•˜ì§€ë§Œ ë°ì´í„°ê°€ ì‚½ì…ë˜ê³  ì‚­ì œë ë•Œ ë‹¤ì‹œ ì¬ì—°ê²°ë§Œ ì‹œì¼œì£¼ë©´ ë˜ëŠ”ê²ƒìœ¼ë¡œ   

ë°°ì—´ì²˜ëŸ¼ ëª¨ë“  ì¸ë±ìŠ¤ê°€ ì´ë™ì´ ì¼ì–´ë‚˜ëŠ”ê²ƒë³´ë‹¤ íš¨ìœ¨ì ì´ë¼ ìƒê°ëœë‹¤.   