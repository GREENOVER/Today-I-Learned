## TIL (Today I Learned)

### 5ì›” 17ì¼ (ì›”)

- #### [í•™ìŠµë‚´ìš©]
  
  ### ìš°ì„ ìˆœìœ„ í ğŸ§‘ğŸ»â€ğŸ’»
    - ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ ìë£Œë“¤ì˜ íë¡œ ìˆœìœ„ê°€ ë†’ì€ ìë£Œê°€ ë¨¼ì € ì‹¤í–‰ (FIFO)
  
    - í™êµ¬ì¡°
  
    - ì™„ì „ì´ì§„íŠ¸ë¦¬ (í™ì€ ì™„ì „ì´ì§„íŠ¸ë¦¬)
  
    - ì™„ì „ì´ì§„íŠ¸ë¦¬: ë§ˆì§€ë§‰ ë…¸ë“œ ë ˆë²¨ì™¸ ë‚˜ë¨¸ì§€ ë…¸ë“œ ë ˆë²¨ì´ ì „ë¶€ ì±„ì›Œì§„ í˜•íƒœì˜ ì´ì§„íŠ¸ë¦¬
  
    - í™í™œìš©: ìµœëŒ€,ìµœì†Œ ê³„ì‚° / í™ì •ë ¬(ìš°ì„ ìˆœìœ„í)

    - ìŠ¤ìœ„í”„íŠ¸ì—ì„œëŠ” ë°°ì—´ë¡œ í‘œí˜„í•˜ëŠ”ê²Œ íš¨ìœ¨ì 
  
    - ë…¸ë“œ ë ˆë²¨ì´ ì˜¬ë¼ê°ˆìˆ˜ë¡ ë…¸ë“œ ìˆ˜ 2ë°°ì”© ì¦ê°€
  
    - ë¶€ëª¨ë…¸ë“œ i / ìì‹ë…¸ë“œ: 2i+1 / 2i+2
  
    - íŠ¸ë¦¬ëŠ” O(log n) / ë°°ì—´ì€ O(1)
  
      
  
  ### Swift ì½”ë“œë¡œ êµ¬í˜„í•˜ê¸° ğŸ“
```swift
    import Foundation

struct Heap<T: Comparable> {
    var nodes: [T] = []
    let sort: (T,T) -> Bool
    
    init(sort: @escaping (T,T) -> Bool) {
        self.sort = sort
    }
    
    // Heapì— ë°ì´í„° ì¶”ê°€ (push)
    mutating func insert(_ element: T) {
        let count = nodes.count
        nodes.append(element)
        
        up(count - 1)
    }
    
    // Heapì—ì„œ ë°ì´í„° êº¼ë‚´ë©´ì„œ ì‚­ì œ (pop)
    mutating func delete() -> T? {
        if nodes.isEmpty {
            return nil
        }
        if nodes.count == 1 {
            return nodes.removeFirst()
        }
        nodes.swapAt(0, nodes.count - 1)
        
        let result = nodes.removeLast()
        down(0)
        
        return result
    }
    
    // Heapì—ì„œ íŠ¹ì • ë°ì´í„° ì‚­ì œ
    mutating func remove(_ element: T) {
        if let index = nodes.firstIndex(of: element) {
            nodes.swapAt(index, nodes.count - 1)
            nodes.removeLast()
            up(index)
            down(index)
        }
    }
    
    // Heapì—ì„œ ë°ì´í„° ì „ì²´ ì‚­ì œ
    mutating func removeAll(_ element: T) {
        var count = nodes.count
        remove(element)
        while nodes.count < count {
            remove(element)
            count = nodes.count
        }
    }
    
    // Heapì—ì„œ ì²« ë°ì´í„° pop
    func peek() -> T? {
        return nodes.first
    }
    
    // Heap ë°ì´í„° ì•„ë˜ë°©í–¥ìœ¼ë¡œ ë¹„êµ ì •ë ¬
    mutating func down(_ index: Int) {
        var index = index
        let count = nodes.count
        while 2 * index + 1 < count {
            var i = 2 * index + 1
            if i < (count - 1) && sort(nodes[i], nodes[i + 1]) {
                i += 1
            }
            if !sort(nodes[index], nodes[i]) {
                break
            }
            nodes.swapAt(index, i)
            index = i
        }
    }
    
    // Heap ë°ì´í„° ìœ—ë°©í–¥ìœ¼ë¡œ ë¹„êµ ì •ë ¬
    mutating func up(_ index: Int) {
        var index = index
        while index > 0 && !sort(nodes[(index - 1)], nodes[index]) {
            nodes.swapAt((index - 1) / 2, index)
            index = (index - 1) / 2
        }
    }
}

var queue: Heap<Int> = Heap<Int>() {
    return $0 > $1
}
queue.insert(3)
queue.insert(5)
queue.insert(2)
queue.insert(1)
queue.insert(6)
queue.insert(7)
queue.insert(4)
// nodes: [7, 5, 6, 1, 3, 2, 4] -- ê²°ê³¼ê°’
```

  ìœ„ì™€ ê°™ì´ ì½”ë“œë¡œ êµ¬í˜„ì„ í•´ë´¤ìŠµë‹ˆë‹¤. 
  ë°ì´í„°ë“¤ì´ ë“¤ì–´ì˜¬ë•Œ ë¶€ëª¨ ë…¸ë“œì™€ ë¹„êµí•˜ì—¬ì¤ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì¶”ê°€/ì‚­ì œ ë“±ì´ ì¼ì–´ë‚ ë•Œ í•´ë‹¹ë˜ëŠ” up/down ë©”ì„œë“œë¥¼ í†µí•´ ë¹„êµ íƒìƒ‰í•˜ë©° ìŠ¤ì™‘í•´ì£¼ë©° ìš°ì„ ìˆœìœ„ íì— ë§ê²Œ ë‹¤ì‹œ ì •ë ¬í•´ì¤ë‹ˆë‹¤.
  ìµœì¢… ì•„ë˜ì— ê°’ë“¤ì„ ì¶”ê°€í•´ì£¼ê³  ì°ì–´ë³´ë©´ ìš°ì„ ìˆœìœ„ëŒ€ë¡œ ë…¸ë“œ ë ˆë²¨ê°„ ì§€ì •ì´ ë˜ìˆìŒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
