## TIL (Today I Learned)

### 12월 3일 (목)

- #### [학습내용]
  오늘은 Step3를 구현해보는 동시에 어제 배운 SOLID에 대해 개념적으로 나름 나만의 정리?를 하며 조금 이해해보려는 시간을 많이 가져보았다.
  SOLID를 개괄적으로? 정리해본다면 객체지향프로그래밍을 위한 5가지 원칙이라고 표현된다. 어떻게 보면 프로그래밍을 하기 위한 디자인 패턴과 같이 어떠한 약속이라고 생각이 들었다. 누구나 보기 편하고 단순하며 확장성이 있는 프로그래밍을 하는것이 중요하다고 생각한다. 이러한 관점에서 SOLID 원칙을 지키며 코딩하는것이 도움이 된다. 

  1. SRP (Single-Responsibility Principle) - 단일책임 원칙
   :한 클래스는 단 한가지의 책임만 가진다.
  한 클래스가 여러 객체에서 책임을 진다면 무언가를 변경해야될 사항이 생기면 여러 부분을 뜯어 고쳐야된다. 예를들어 같이 협업을 하고 있다는 가정하에 공통된 클래스를 가져와서 서로 다른 부분을 구현하고 있다. 그런데 만약 A파트에서 기획이 변경되어 해당 클래스의 어떠한 부분의 추가나 변경이 이뤄져야한다면 B파트는 난감할것이다. 이렇게 클래스를 응집도가 있는 것끼리 최소한으로 책임을 갖게해야 합니다.

  2. OCP (Open-Close Principle) - 개방/폐쇄 원칙
   : 확장이 가능하도록 개방되어있고 변경에는 폐쇄적이여야한다.
  만약 새로운 기능이 추가된다면 기존에서 변경하거나 추가하지말고 새로운 클래스나 메서드를 생성하여 추가해주는것이 좋다. 다른것을 건드리지않고 코드의 추가만으로 확장에 용이하며 변경에는 폐쇄적이 된다.
  예를들어, 프로토콜과 열거형이 있다.
  프로토콜로 구현한 코드에서 추후 어떠한 타입이나 메서드/프로퍼티가 추가될때는 과연 어떨까 정리해보았다.

    - 프로토콜    
  -. 타입추가
    ```swift
  protocol Punch { }
  struct SoftPunch: Punch { }
  struct HardPunch: Punch { }
    ```
  이렇게 있을때, 어떤 냥냥펀치라는 새로운 펀치의 타입을 확장해주고 싶다면 간단하게 
    ```swift
  struct CatPunch: Punch { }
    ```
  처럼 한 줄의 코드만으로 확장을 시키며 프로토콜의 내부 변경이나 다른 구조체의 변경이 이뤄지지 않는다.

  -. 메서드/프로퍼티 추가

    ```swift
  protocol Punch {  
  func left()  
  func right()
  }
    ```
  이러한 프로토콜이 존재할때 프로토콜안에서 어떠한 메서드와 프로퍼티를 넣어주게 된다면 프로토콜을 채택한 소프트/미들/냥냥펀치의 메서드 안에서도 구현을 일일히 해주면서 코딩을 해야하는 번거로움이 생긴다.
  이 부분은 확장에는 용이하지 않고 변경이 이뤄지기에 OCP원칙에 위배된다.
  이렇게 보자면 프로토콜은 메서드/프로퍼티 추가보다는 타입을 추가할때 용이하다고 볼 수 있다.

     -. 열거형
  그 다음으로, 열거형 (enum)을 보면,
  열거형은 프로토콜과 반대의 성향을 가진다.

     -. 타입추가
     ```swift
    enum Punch {  
    case softPunch  
    case hardPunch  
    func left()  
    func right()
    }
     ```
  이럴경우 만약 또 냥냥펀치의 타입이 필요할경우 위 코드에서 left/ right 메서드의 해당 케이스를 다 넣어주어야 하는 귀찮음이 발생한다. OCP에 위배가 되는 것이다. 그러면 메서드/프로퍼티 추가일때는 어떨지 보았다

     -. 메서드/프로퍼티 추가
     ```swift
enum Punch {  
	case softPunch  
	case hardPunch  
	func left()  
	func right()
}
     ```
이럴때 막기라는 동작의 메서드를 구현할때 프로토콜에서는 채택한 모든 구조체에 대해 일일히 코딩을 해줬다라하면 열거형에서는 위의 코드에서 해당 구현할 메서드를 추가해주기만 하면 된다.
즉, 다시한번 정리하면 프로토콜: 타입추가 / 열거형: 메서드,프로퍼티 추가 시 OCP를 위배하지 않는다고 할 수 있다.

  3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙
 : 자식클래스가 부모클래스로의 역할을 다 수행해야한다.
리스코프?? 말만들어도 어렵다.. 아직도 조금 헷갈리는 5가지 원칙중 하나이다.
조금 쉽게 말한다면 "상위 타입 객체를 하위 타입 객체로 치환해도 상위 타입을 사용하는 기능이 정상적이여야 한다" 라고 말할 수 있을것 같다. 음 아직도 감이 잘 안오긴하지만.. 상속과 관련이 있는것 같기도하고 부모클래스의 모든 부분을 그대로 구현해줘야하나 싶기도하고..
만약 펀치의 메서드중 왼쪽 펀치라는 기능을 가진 클래스를 냥냥펀치가 상속 받았다고 생각해보면, 냥냥펀치의 왼쪽 펀치 메서드의 기능을 왼쪽 발차기로 변경했다하면 오류가 난다.
냥냥펀치를 부모인 펀치로 대입했을때 되지 않기 때문이다.
리스코프 치환 원칙을 검색하면 제일 대표적으로 많이 나오는 정사각형 직사각형으로 이해는 어느정도 하였는데 실제로 코드에서 지켜보면서 느껴봐야 할것 같다.

  4. ISP (Interface Segregation Principle) - 인터페이스 분리 법칙
 : 인터페이스는 최대한 작게 가져가야한다.
불필요한 메서드를 구현할 필요가 없다. 불필요한 메서드를 받아오는 쪽에서는 구현하지 않게되면 텅 빈 구현이 되기때문이다.
이 원칙이 가장 많이 와닿았다. 코딩을 하다보면 어느 단위로 쪼갤지 어떤 기능 메서드로 나눌지 생각이 든다.
그런것과 마찬가지로 인터페이스 분리 법칙을 생각해보면 좋을것 같다.

  5. DIP (Dependency Inversion Priciple) - 의존성 역전 원칙
 : 상위수준 모듈은 하위수준 모듈에 의존하면 안된다.
구체적 사항은 추상화에 의존해야한다. 인데.. 음 구체적인것은 변하기 쉽지만 추상적인것은 개념이라던지 그런것들이 변할 그런게 적으니까 그런것같다고 생각한다. 음.. 간단히 최대한 간단히 생각해보면 상위모듈보다 하위모듈이 더 쉽게 변하니까 거기에 의존하지 말라는 뜻이라 생각한다.

  SOLID에 대해서는 하나씩 실제로 사용해보며 익혀봐야겠다..!

- #### [고민 포인트]
의존모둠제를 오늘은 적극 활용이 되었던 날인것같다. 우선 꼬말/오동나무 모둠의 질문을 받았다. 질문은 앱 배포 버전에 관한것이었다. 이번 프로젝트의 Deployment Info가 iOS 12.0 버전으로 맞춰져있었다. 그러다보니 iOS 13.0 버전부터 자동으로 생성되는 SceneDelegate를 메서드에 @available(iOS 13.0, *)을 해주지 않는다면 빌드가 되지 않았다. 처음 우리 모둠은 의도를 파악하지 못하고 Deployment Info iOS 13.0으로 변경해줌으로 별 고민없이 넘어갔던 부분이다. 그런데 iOS 12.0 버전을 쓰는 사용자들도 많은데 그 사용자는 배제될 수 있는데 어떻게 하면 모두 사용이 가능하게끔할것이며 또 @available로 iOS 13.0 이전 버전 사용자들이 해당 SceneDelegate등을 타지 않고 사용이 되긴 하는데 무슨 차이가 있는지 13 이전 이후 버전의 사용자들을 조건을 비교하여 버전에 맞게 구현해줄 수 있는지의 질문이였다.

- #### [고민에 대한 노력]
사실 이부분에 대해 크게 생각해보지 않았었는데 질문을 받으니 ‘아 이런것도 깊게 파고들고 궁금해할 수 있구나’ 라는 놀라움과 꼬말/오동나무의 정확하게 알고 넘어갈 수 있게 파고드는 열정이 부러워졌고 무언가 더 자극을 받게 되었다. 그래서 우선 왜 그런지에 대해 찾아보았다. 우선 13 버전으로 오면서 SceneDelegate가 자동으로 생성되며 active, resign and disconnect 같은 라이프사이클 이벤트가 담겨있다. 그러다보니 AppDelegate에서도 scene sessions에 관련되어 있는 2개의 메서드
  1. application(_:configurationForConnecting:options:)
  2. application(_:didDiscardSceneSessions:)

  가 추가되었다. 만약 13 이전 버전으로 deployment target을 설정한다면 위의 13 버전 이후 나온것들을 사용할 수 없게된다. 그래서 @available(iOS 13.0, *)을 해줌으로 13버전이면 그대로 사용하고 13버전 이전이면 해당 추가된 것들을 무시하게된다. 그런데 또 찾아보며 궁금했던것이 저렇게 13 이전 버전이 해당 추가된것을 무시하게 된다면 어떠한 문제가 있지 않을까? 무언가 13 이전 버전에서 사용하던 뷰 라이프 싸이클이라던지 기존에 13 이전 버전에서 존재하던 Appdelegate을 사용을 하는것인지 아니면 코드로 버전에 따른 사용을 명시하며 구현해줘야하는것인지 궁금했다. 그래서 찾아보며 나의 의존모둠인 태태에게도 의견을 구했다. 태태와 의견을 나누며 조금 가설을 짓고 생각한것이 Appdelegate를 보면 함수가 3개인데 처음 함수는 13 이전 버전에 대한 것이고 다음 함수 2개는 13 버전 이후 생긴함수이다. 이걸 보았을때 13 이전 버전은 처음 함수를 타기에 이미 그 자체가 조건이 된거라고 생각해보았다. 그리고 어떤 문제가 있는지 보기위해 구동을 해보며 돌려보았는데 검은 화면이 나왔다. 메시지를 확인해보니 “[Application] The app delegate must implement the window property if it wants to use a main storyboard file.” 라는걸 알려주고 있었다. 윈도우 프로퍼티를 원하는것 같다. 무언가 잘못되었으니까 그렇겠지? 라는 생각으로 찾아보다가 발견한것이 있었다. 13 이전 버전에서는 Xcode에서 프로젝트가 생성될 때 자동으로 AppDelegate에 window 프로퍼티를 생성해주지만 13 이후 버전부터는 SceneDelegate가 생성되면서 window 프로퍼티가 SceneDelegate에 생성이 되었고 실제로 SceneDelegate를 보면 해당 window 프로퍼티가 선언되있는걸 볼 수 있었다. 이에 AppDelegate에서 window 프로퍼티를 선언해줌으로 정상적으로 화면 노출이 될 수 있었다. 이 부분에 대해 조금 더 알고 싶고 더 찾아볼 예정인것들이 많아졌다. 의존모둠의 중요성을 확연하게 느끼게 되었고 알고있던 모르던 간에 질문은 정말 좋은것 같다. 꼬말/오동나무/태태와 한마디라도 더 의견을 나누며 많이 성장했던것 같다.