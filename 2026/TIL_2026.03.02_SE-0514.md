# [SE-0514] Hashable Conformance for Dictionary.Keys, CollectionOfOne and EmptyCollection

ì•ˆë…•í•˜ì„¸ìš”. **ê·¸ë¦°**ì…ë‹ˆë‹¤ ğŸ

ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” **SE-0514 Hashable Conformance for Dictionary.Keys, CollectionOfOne and EmptyCollection**ì— ëŒ€í•´ ì •ë¦¬í•´ë³´ê² ìŠµë‹ˆë‹¤ ğŸ™‹ğŸ»

![](https://blog.kakaocdn.net/dna/HVeWe/dJMcafSRrXb/AAAAAAAAAAAAAAAAAAAAAAJs8xe3OesyH7G7W1XDSR4hjebY9WlA3bmv9Pxgk_Lk/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=jkxk7U0mSLO2OahDrayZVRhZg5E%3D)

---

## **Intro**

Swift í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ëª‡ëª‡ collection íƒ€ì…ë“¤ì´ `Hashable`ì„ conformí•˜ì§€ ì•ŠëŠ” ê²Œ ìˆìŠµë‹ˆë‹¤.

`Dictionary.Keys`, `CollectionOfOne`, `EmptyCollection`ì´ ë°”ë¡œ ê·¸ê²ƒë“¤ì¸ë°ìš”.

ì´ë²ˆ SE-0514ëŠ” ì´ ì„¸ íƒ€ì…ì— `Hashable` conformanceë¥¼ ì¶”ê°€í•˜ëŠ” ì œì•ˆì…ë‹ˆë‹¤.

íŠ¹íˆ `Dictionary.Keys`ëŠ” ëª¨ë“  keyê°€ ì´ë¯¸ `Hashable`ì¸ë° keys view ìì²´ëŠ” `Hashable`ì´ ì•„ë‹Œ ê²Œ ì¢€ ì´ìƒí•˜ì£ .

ê°„ë‹¨í•˜ì§€ë§Œ ì¼ê´€ì„±ì„ ë†’ì—¬ì£¼ëŠ” ê°œì„ ì…ë‹ˆë‹¤ ğŸš€

í˜„ì¬ 2026ë…„ 3ì›” 6ì¼ê¹Œì§€ ë¦¬ë·°ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤!

---

## **ì™œ í•„ìš”í•œê°€?**

### **Dictionary.Keys**

`Dictionary.Keys`ëŠ” ë‹¨ìˆœíˆ dictionaryì˜ keysì— ëŒ€í•œ viewì…ë‹ˆë‹¤.

Dictionaryì˜ ëª¨ë“  keyëŠ” `Hashable`ì„ conformí•˜ì£ .

ë”°ë¼ì„œ `Dictionary.Keys` ìì²´ë„ ìë™ìœ¼ë¡œ ê·¸ë¦¬ê³  ë¬´ì¡°ê±´ì ìœ¼ë¡œ `Hashable`ì„ conformí•´ì•¼ í•©ë‹ˆë‹¤.

### **CollectionOfOneê³¼ EmptyCollection**

`CollectionOfOne`ê³¼ `EmptyCollection`ì€ ìƒëŒ€ì ìœ¼ë¡œ ëœ ì‚¬ìš©ë˜ëŠ” íƒ€ì…ë“¤ì…ë‹ˆë‹¤.

ì´ë“¤ì— `Hashable` conformanceë¥¼ ì¶”ê°€í•˜ëŠ” ê±´ ì™„ì „ì„±ê³¼ ë‹¤ë¥¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ collection íƒ€ì…ë“¤ê³¼ì˜ ì¼ê´€ì„±ì„ ìœ„í•´ì„œì…ë‹ˆë‹¤.

ì°¸ê³ ë¡œ `CollectionOfOne`ì€ `Equatable`ë„ conformí•˜ì§€ ì•Šì•„ì„œ, ì´ ì œì•ˆì—ì„œëŠ” ê·¸ê²ƒë„ í•¨ê»˜ ì¶”ê°€í•©ë‹ˆë‹¤.

---

## **ì œì•ˆëœ í•´ê²°ì±…**

í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ë‹¤ìŒì„ ì¶”ê°€í•©ë‹ˆë‹¤:

+ `Dictionary.Keys`ì™€ `EmptyCollection`: ë¬´ì¡°ê±´ì  `Hashable` conformance
+ `CollectionOfOne`: ì¡°ê±´ë¶€ `Equatable`ê³¼ `Hashable` conformance

---

## **ìƒì„¸ ì„¤ê³„**

### **Dictionary.Keys**

`Dictionary.Keys`ëŠ” ë¬´ì¡°ê±´ì  `Hashable` conformanceë¥¼ ì–»ìŠµë‹ˆë‹¤.

Dictionaryì˜ keyëŠ” í•­ìƒ `Hashable`ì´ë‹ˆê¹Œìš”.

Hash êµ¬í˜„ì€ **commutative hashing algorithm**(ê°œë³„ element hashì˜ XOR)ì„ ì‚¬ìš©í•´ì„œ, ë‘ `Dictionary.Keys` collectionì´ ê°™ì€ elementë¥¼ í¬í•¨í•˜ë©´ iteration orderì™€ ê´€ê³„ì—†ì´ ê°™ì€ hash valueë¥¼ ê°–ë„ë¡ í•©ë‹ˆë‹¤.

```swift
extension Dictionary.Keys {
  @_alwaysEmitIntoClient
  public func hash(into hasher: inout Hasher) {
    var commutativeHash = 0
    for element in self {
      // Note that, similar to `Set`'s and `Dictionary`'s hashing algorithms, we use a copy of our own hasher here.
      // This makes hash values dependent on its state, eliminating static collision patterns.
      var elementHasher = hasher
      elementHasher.combine(element)
      commutativeHash ^= elementHasher._finalize()
    }
    hasher.combine(commutativeHash)
  }

  @_alwaysEmitIntoClient
  public var hashValue: Int { // Prevent compiler from synthesizing hashValue.
    var hasher = Hasher()
    self.hash(into: &hasher)
    return hasher.finalize()
  }
}

@available(SwiftStdlib 6.4, *)
extension Dictionary.Keys: Hashable {}
```

#### **ì‚¬ìš© ì˜ˆì‹œ**

```swift
let batch1 = ["apple": 1, "banana": 2, "cherry": 3, "date": 4]
let batch2 = ["date": 10, "banana": 20, "apple": 30, "cherry": 40]
let batch3 = ["mango": 5, "orange": 6, "papaya": 7]

let uniqueBatches = Set([batch1.keys, batch2.keys, batch3.keys])

print(uniqueBatches)
// [Dictionary.Keys(["orange", "mango", "papaya"]), Dictionary.Keys(["banana", "apple", "date", "cherry"])]
```

> `batch1.keys`ì™€ `batch2.keys`ëŠ” ê°™ì€ keyë“¤ì„ í¬í•¨í•˜ë¯€ë¡œ `Set`ì—ì„œ í•˜ë‚˜ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤!

---

### **CollectionOfOne**

`CollectionOfOne`ì€ ì¡°ê±´ë¶€ conformanceë¥¼ ì–»ìŠµë‹ˆë‹¤:

+ `Element`ê°€ `Equatable`ì´ë©´ `Equatable`
+ `Element`ê°€ `Hashable`ì´ë©´ `Hashable`

Hash valueëŠ” í¬í•¨í•˜ê³  ìˆëŠ” ë‹¨ì¼ elementì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.

```swift
extension CollectionOfOne where Element: Equatable {
  @_alwaysEmitIntoClient
  public static func ==(lhs: CollectionOfOne<Element>, rhs: CollectionOfOne<Element>) -> Bool {
    return lhs._element == rhs._element
  }
}

extension CollectionOfOne where Element: Hashable {
  @_alwaysEmitIntoClient
  public func hash(into hasher: inout Hasher) {
    hasher.combine(self._element)
  }

  @_alwaysEmitIntoClient
  public var hashValue: Int { // Prevent compiler from synthesizing hashValue.
    var hasher = Hasher()
    self.hash(into: &hasher)
    return hasher.finalize()
  }
}

@available(SwiftStdlib 6.4, *)
extension CollectionOfOne: Equatable where Element: Equatable {}

@available(SwiftStdlib 6.4, *)
extension CollectionOfOne: Hashable where Element: Hashable {}
```

---

### **EmptyCollection**

`EmptyCollection`ì€ ë¬´ì¡°ê±´ì  `Hashable` conformanceë¥¼ ì–»ìŠµë‹ˆë‹¤.

ëª¨ë“  empty collectionì€ element íƒ€ì…ê³¼ ê´€ê³„ì—†ì´ ë™ì¼í•˜ë¯€ë¡œ, ëª¨ë‘ ê°™ì€ hash valueë¥¼ ê°€ì§‘ë‹ˆë‹¤.

Hash í•¨ìˆ˜ëŠ” ë‹¨ìˆœíˆ ê°’ 0ì„ combineí•˜ëŠ”ë°, ì´ëŠ” empty set, dictionary, arrayì˜ hashing conventionê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤.

```swift
extension EmptyCollection {
  @_alwaysEmitIntoClient
  public func hash(into hasher: inout Hasher) {
    hasher.combine(0)
  }

  @_alwaysEmitIntoClient
  public var hashValue: Int { // Prevent compiler from synthesizing hashValue.
    var hasher = Hasher()
    self.hash(into: &hasher)
    return hasher.finalize()
  }
}

@available(SwiftStdlib 6.4, *)
extension EmptyCollection: Hashable {}
```

---

## **í˜¸í™˜ì„±**

### **Source compatibility**

ìˆœìˆ˜í•˜ê²Œ additiveí•œ ë³€ê²½ì…ë‹ˆë‹¤.

ë‹¤ë§Œ ì´ë¯¸ ìì²´ì ìœ¼ë¡œ redundant conformanceë¥¼ ì œê³µí•œ ì½”ë“œëŠ” ê²½ê³ ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### **ABI compatibility**

í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ABIì˜ ìˆœìˆ˜í•œ í™•ì¥ì´ê³ , ê¸°ì¡´ ê¸°ëŠ¥ì€ ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

---

## **Adoption ì˜í–¥**

ìƒˆë¡œìš´ conformanceëŠ” Swift 6.4 ì´ìƒì´ í•„ìš”í•©ë‹ˆë‹¤.

ì´ì „ Swift ë²„ì „ì„ ì§€ì›í•´ì•¼ í•œë‹¤ë©´ ì´ë ‡ê²Œ í•˜ë©´ ë©ë‹ˆë‹¤:

```swift
#if swift(<6.4)
  extension Dictionary.Keys: @retroactive Hashable {}
#endif
```

> ì°¸ê³ : ì´ì „ Swift ë²„ì „ì—ì„œ ì´ë¯¸ ì´ëŸ° í•¨ìˆ˜ë¥¼ êµ¬í˜„í–ˆë‹¤ë©´, ëŸ°íƒ€ì„ì— binary compatibility ì´ìŠˆê°€ ë°œìƒí•  ë‚®ì€ ì´ë¡ ì  ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ êµ¬í˜„ì´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„ê³¼ ê·¼ë³¸ì ìœ¼ë¡œ í˜¸í™˜ë˜ì§€ ì•Šê±°ë‚˜ ì¶©ëŒí•˜ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

---

## **ê³ ë ¤ëœ ëŒ€ì•ˆë“¤**

### **EmptyCollectionì˜ Hashable conformanceë¥¼ í¬í•¨í•˜ì§€ ì•Šê¸°?**

ì™„ì „ì„±ê³¼ ë‹¤ë¥¸ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ collection íƒ€ì…ë“¤ê³¼ì˜ ì¼ê´€ì„± ì™¸ì—ë„, hash-based contextì—ì„œ `EmptyCollection`ì„ ì‚¬ìš©í•˜ëŠ” ì¼€ì´ìŠ¤ëŠ” í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ `result ?? EmptyCollection<T>` ëŒ€ì‹  ë‹¤ë¥¸ ë°©ë²•ì„ ì“¸ ìˆ˜ë„ ìˆì£ .

í•˜ì§€ë§Œ ê·¸ëŸ° workaroundê°€ í•´ë‹¹ use caseì— idiomaticí•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> ê·¸ë˜ì„œ ì¼ê´€ì„±ì„ ìœ„í•´ í¬í•¨ì‹œí‚¤ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.

---

## **Conclusion**

í˜„ì¬ SE-0514ëŠ” 2026ë…„ 3ì›” 6ì¼ê¹Œì§€ ë¦¬ë·°ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.

ê°œì¸ì ìœ¼ë¡œëŠ” ì •ë§ ë‹¹ì—°í•˜ê²Œ ìˆì–´ì•¼ í•  conformanceë“¤ì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.

íŠ¹íˆ `Dictionary.Keys`ëŠ” ëª¨ë“  keyê°€ ì´ë¯¸ `Hashable`ì¸ë° keys viewê°€ `Hashable`ì´ ì•„ë‹Œ ê²Œ ì´ìƒí–ˆê±°ë“ ìš”.

`CollectionOfOne`ê³¼ `EmptyCollection`ì€ ëœ ì‚¬ìš©ë˜ì§€ë§Œ, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì¼ê´€ì„±ì„ ë†’ì—¬ì£¼ëŠ” ì¢‹ì€ ì¶”ê°€ì…ë‹ˆë‹¤.

ê°„ë‹¨í•˜ì§€ë§Œ ì‹¤ë¬´ì—ì„œ ë¶„ëª… ë„ì›€ì´ ë  ê²ƒ ê°™ë„¤ìš” ğŸ˜ƒ

---

## **References**

[swift-evolution/proposals/0514-hashable-conformance-for-dictionarykeys-collectionofone-emptycollection.md at main Â· swiftlang/swift-evolution](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0514-hashable-conformance-for-dictionarykeys-collectionofone-emptycollection.md)

[Pitch: Hashable conformance for Dictionary.Keys, CollectionOfOne and EmptyCollection - Swift Forums](https://forums.swift.org/t/pitch-hashable-conformance-for-dictionary-keys-collectionofone-and-emptycollection/84117)

[SE-0514: Hashable conformance for Dictionary.Keys, CollectionOfOne and EmptyCollection - Swift Forums](https://forums.swift.org/t/se-0514-hashable-conformance-for-dictionary-keys-collectionofone-and-emptycollection/84852)
