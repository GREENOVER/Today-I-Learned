## TIL (Today I Learned)

### 2ì›” 8ì¼ (ì¼)    
# [SE-0507] Borrow and Mutate Accessors

ì•ˆë…•í•˜ì„¸ìš”. **ê·¸ë¦°**ì…ë‹ˆë‹¤ ğŸ

ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” **SE-0507 Borrow and Mutate Accessors**ì— ëŒ€í•´ ì •ë¦¬í•´ë³´ê² ìŠµë‹ˆë‹¤ ğŸ™‹ğŸ»

## **Intro**

Swiftì˜ property accessorëŠ” ê³„ì† ì§„í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤.

ê¸°ì¡´ì—ëŠ” `get`, `set`, ê·¸ë¦¬ê³  ìµœê·¼ ì¶”ê°€ëœ `yielding borrow`, `yielding mutate`ê°€ ìˆì—ˆëŠ”ë°ìš”.

ì´ë²ˆ SE-0507ì€ ìƒˆë¡œìš´ `borrow`ì™€ `mutate` accessorë¥¼ ì œì•ˆí•©ë‹ˆë‹¤.

ì´ë“¤ì€ **borrowing semantics**ë¥¼ ì‚¬ìš©í•´ì„œ ë³µì‚¬ ì˜¤ë²„í—¤ë“œ ì—†ì´ ê°’ì— ì ‘ê·¼í•  ìˆ˜ ìˆê³ , yielding accessorë³´ë‹¤ ì„±ëŠ¥ì´ ì¢‹ìŠµë‹ˆë‹¤.

íŠ¹íˆ non-copyable íƒ€ì…ì„ ë‹¤ë£¨ëŠ” collectionì´ë‚˜ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ì €ìˆ˜ì¤€ ë°ì´í„° êµ¬ì¡°ì— ìœ ìš©í•  ê±°ì˜ˆìš” ğŸš€

í˜„ì¬ 2026ë…„ 2ì›” 9ì¼ê¹Œì§€ ë¦¬ë·°ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤!

---

## **ì™œ í•„ìš”í•œê°€?**

ê¸°ì¡´ accessorë“¤ì€ ê°ê° í•œê³„ê°€ ìˆìŠµë‹ˆë‹¤.

### **ë¬¸ì œ 1: `get`ì€ ë³µì‚¬í•´ì•¼ í•œë‹¤**

`get` accessorëŠ” ê°’ì„ ë³µì‚¬í•˜ê±°ë‚˜ ìƒˆë¡œ ìƒì„±í•´ì„œ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.

ë³µì‚¬ê°€ ë¹„ì‹¸ê±°ë‚˜ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ì—” ì“¸ ìˆ˜ ì—†ì£ .

```swift
struct NC: ~Copyable { ... }
struct ContainerOfNoncopyable {
    private var _element: NC
    var element: Element {
        return _element // ğŸ›‘ ERROR: Cannot copy `_element`
    }
}
```

Non-copyable ê°’ì„ ì €ì¥í•˜ëŠ” collectionì€ subscriptì— `get`ì„ ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

### **ë¬¸ì œ 2: yielding accessorëŠ” ì˜¤ë²„í—¤ë“œê°€ í¬ë‹¤**

`yielding mutate`ì™€ `yielding borrow`ëŠ” coroutineì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

ì ‘ê·¼ ì „í›„ë¡œ ì½”ë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆì–´ì„œ ìœ ì—°í•˜ì§€ë§Œ, ê·¸ë§Œí¼ ì˜¤ë²„í—¤ë“œê°€ ìˆìŠµë‹ˆë‹¤.

+ Coroutineì„ ìœ„í•œ ë©”ëª¨ë¦¬ í• ë‹¹
+ ì—¬ëŸ¬ ë²ˆì˜ í•¨ìˆ˜ í˜¸ì¶œ
+ ì ‘ê·¼ scopeê°€ ì œí•œë¨ (í•¨ìˆ˜ê°€ ëë‚˜ê¸° ì „ì— ì™„ë£Œë˜ì–´ì•¼ í•¨)

```swift
struct Element: ~Copyable {
  var span: Span<...> { ... }
}

struct Wrapper: ~Copyable {
    private var _element: Element
    var element: Element {
        yielding borrow { // â—ï¸Note: Using `yielding borrow` accessor
            yield _element
        }
    }
}

func getSpan(wrapper: borrowing Wrapper) -> Span<...> {
    // Because we're reading `element` from a yielding accessor,
    // its access must finish before `getSpan` returns.
    // But `span` cannot outlive `element`, so ...

    // ğŸ›‘ ERROR: lifetime-dependent value escapes its scope
    return wrapper.element.span
}
```

> Borrowing accessorëŠ” ì´ ë‘ ë¬¸ì œë¥¼ ëª¨ë‘ í•´ê²°í•©ë‹ˆë‹¤.

---

## **ì œì•ˆëœ í•´ê²°ì±…**

ìƒˆë¡œìš´ `borrow`ì™€ `mutate` í‚¤ì›Œë“œë¡œ accessorë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

```swift
struct RigidWrapper<Element: ~Copyable>: ~Copyable {
    var _element: Element
    var element: Element {
        borrow {
            return _element
        }
        mutate {
            return &_element
        }
    }
}
```

+ `borrow`: ì½ê¸° ì „ìš© ì ‘ê·¼, ë³µì‚¬í•˜ì§€ ì•ŠìŒ
+ `mutate`: ì½ê¸°/ì“°ê¸° ì ‘ê·¼, `&`ë¡œ mutable reference ë°˜í™˜

`yield` ëŒ€ì‹  `return`ì„ ì“°ëŠ” ê²Œ ì°¨ì´ì ì…ë‹ˆë‹¤.

> ë¬¼ë¡  single expressionì´ë©´ `return` í‚¤ì›Œë“œëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

## **ìƒì„¸ ì„¤ê³„**

### **ë°˜í™˜ ê°’ì˜ ì œì•½**

Borrowing accessorëŠ” **ì €ì¥ëœ ê°’**ë§Œ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

localì´ë‚˜ temporary ê°’ì€ ë°˜í™˜í•  ìˆ˜ ì—†ì–´ìš”.

```swift
struct InvalidExamples {
    var _array : [Int]
    
    var local: [Int] {
        borrow {
            let foo = [1, 2, 3]
            // ğŸ›‘ ERROR: Cannot return local value from borrow accessor
            return foo
        }
    }
    
    var temporary: [Int]? {
        borrow {
            // This would require creating a temporary local
            // optional array from `_array`.
            // ğŸ›‘ ERROR: Cannot return temporary value from borrow accessor
            return _array
        }
    }
}
```

ë°˜í™˜í•˜ëŠ” ê°’ì€ accessor ì‹¤í–‰ì´ ëë‚œ í›„ì—ë„ ìœ íš¨í•´ì•¼ í•©ë‹ˆë‹¤.

---

## **ì‚¬ìš© ë°©ë²•**

### **borrowë¡œ ì½ê¸°**

í´ë¼ì´ì–¸íŠ¸ ì½”ë“œëŠ” ê¸°ì¡´ `get`ê³¼ ë™ì¼í•˜ê²Œ ë³´ì´ì§€ë§Œ, ë‚´ë¶€ì ìœ¼ë¡œëŠ” ë³µì‚¬ê°€ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```swift
var owner = Wrapper(value)

// "borrow" the value to give to a function
// without copying...
doSomething(with: owner.element)

func doSomething(with value: borrowing Element) {
    // `value` is borrowed, so this invokes
    // the method "in-place"
    value.someMethod() 

    // Exclusivity prevents the owner from being
    // mutated while `value` is alive:
    owner.mutatingMethod() // ğŸ›‘ ERROR
}
```

ë©”ëª¨ë¦¬ ì¼ê´€ì„±ì„ ìœ„í•´ Swiftì˜ exclusivity ruleì´ ì ìš©ë©ë‹ˆë‹¤.

borrowê°€ í™œì„±í™”ëœ ë™ì•ˆì—” ownerë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ì–´ìš”.

### **mutateë¡œ ìˆ˜ì •í•˜ê¸°**

`mutate` accessorëŠ” ì½ê¸°/ì“°ê¸° ì ‘ê·¼ì„ ì œê³µí•©ë‹ˆë‹¤.

```swift
var owner = Wrapper(value)

// Mutating/inout access will invoke the `mutate` accessor
doSomething(with: &owner.element)

func doSomeMutation(with value: inout Element) {
    // So this invokes a method on the value "in-place"
    // Because you borrowed for mutation, this can be
    // a mutating method.
    value.someMutatingMethod()

    // Accessing the owner is an exclusivity violation
    owner.anyMethod() // ğŸ›‘ ERROR
}
```

---

## **ë‹¤ë¥¸ accessorì™€ì˜ í˜¸í™˜ì„±**

### **mutateë¥¼ ì œê³µí•˜ë©´**

+ `borrow`ë„ ë°˜ë“œì‹œ ì œê³µí•´ì•¼ í•¨
+ `yielding mutate`ë‚˜ `yielding borrow`ëŠ” ì‚¬ìš© ë¶ˆê°€

SwiftëŠ” ì¼ë°˜ì ìœ¼ë¡œ write-only propertyë¥¼ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ë˜í•œ ì½ê¸°ì™€ ì“°ê¸° ì‘ì—…ì˜ ì ‘ê·¼ scopeë¥¼ ì¼ê´€ë˜ê²Œ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

### **borrowë¥¼ ì œê³µí•˜ë©´**

+ `get`ì´ë‚˜ `yielding borrow`ëŠ” ì‚¬ìš© ë¶ˆê°€

ì—¬ëŸ¬ read accessorë‚˜ ì—¬ëŸ¬ write accessorë¥¼ ë™ì‹œì— ì •ì˜í•˜ë©´ í˜¸ì¶œì ì…ì¥ì—ì„œ í˜¼ë€ìŠ¤ëŸ½ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

## **Ownership ë³€í˜•**

ê¸°ë³¸ì ìœ¼ë¡œ:
+ `borrow`: í¬í•¨í•˜ëŠ” ê°’ì„ ë³€ê²½í•˜ì§€ ì•ŠìŒ
+ `mutate`: í¬í•¨í•˜ëŠ” ê°’ì„ ë³€ê²½í•¨

ì´ê±¸ `mutating`ì´ë‚˜ `nonmutating` í‚¤ì›Œë“œë¡œ ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### **mutating borrow**

ì½ê¸° ì „ìš©ì´ì§€ë§Œ side-effectë¡œ ì¸í•´ í¬í•¨í•˜ëŠ” ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

```swift
struct S1 {
  private var cachedValue: Foo
  var foo : Foo {
    mutating borrow {
      if !cachedValue.available {
        // Update `cachedValue`
        // Compiler allows such update
        // because this is `mutating`
      }
      return cachedValue
    }
  }
}

let s1: S1 // Note: Immutable value
s1.foo // ğŸ›‘ Cannot use mutating accessor on immutable value
```

ìºì‹œë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²½ìš° ê°™ì€ ê±°ì£ .

### **nonmutating mutate**

ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆì§€ë§Œ ë¶€ëª¨ ê°’ì˜ ë³€ê²½ìœ¼ë¡œ ê°„ì£¼ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

```swift
struct Outer {
  var inner: InnerType {
    borrow {
      return some_value_stored_elsewhere
    }
    nonmutating mutate {
      return &some_value_stored_elsewhere
    }
  }
}
```

ì™¸ë¶€ì— ì €ì¥ëœ ê°’ì— ì ‘ê·¼í•˜ëŠ” ê²½ìš° ê°™ì€ ê±°ì˜ˆìš”.

---

## **Protocol requirementë¡œ ì‚¬ìš©**

Protocolì—ì„œë„ borrowing accessorë¥¼ ìš”êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```swift
protocol BorrowingAccess {
  associatedtype Element
  var element: Element { borrow mutate }
}
```

ì´ëŠ” ë‘ ê°€ì§€ íš¨ê³¼ê°€ ìˆìŠµë‹ˆë‹¤:

1. Protocolì„ í†µí•œ ì ‘ê·¼ ë°©ì‹ì„ ì œì–´ (existentialì´ë‚˜ generic argumentì—ì„œ)
2. conforming íƒ€ì…ì— í•´ë‹¹ accessorê°€ ìˆì–´ì•¼ í•¨ (ëª…ì‹œì  êµ¬í˜„ ë˜ëŠ” ì»´íŒŒì¼ëŸ¬ í•©ì„±)

### **ì»´íŒŒì¼ëŸ¬ í•©ì„±**

+ Stored property â†’ `borrow`, `mutate` í•©ì„± ê°€ëŠ¥
+ `borrow` êµ¬í˜„ â†’ `yielding borrow`ë‚˜ `get` í•©ì„± ê°€ëŠ¥ (copyableë§Œ)
+ `mutate` êµ¬í˜„ â†’ `set`ì´ë‚˜ `yielding mutate` í•©ì„± ê°€ëŠ¥

### **ì œì•½ì‚¬í•­**

+ Protocolì´ `borrow` ìš”êµ¬ â†’ conforming íƒ€ì…ë„ `borrow` í•„ìš”
+ Protocolì´ `mutate` ìš”êµ¬ â†’ conforming íƒ€ì…ì€ `borrow`ì™€ `mutate` ëª¨ë‘ í•„ìš”

---

## **Classì™€ Actorì—ì„œëŠ” ë¶ˆê°€**

ClassëŠ” property ì ‘ê·¼ ì „í›„ë¡œ runtime exclusivity checkë¥¼ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤.

Borrowing accessorëŠ” ì ‘ê·¼ í›„ì— ì½”ë“œë¥¼ ì‹¤í–‰í•  ë°©ë²•ì´ ì—†ì–´ì„œ class propertyì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

> `yielding borrow`ì™€ `yielding mutate`ëŠ” class propertyì— ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

## **Subscriptì—ë„ ì‚¬ìš© ê°€ëŠ¥**

```swift
struct ArrayLikeType {
  subscript(index: Int) -> Element {
    borrow { .... }
    mutate { .... }
  }
}
```

ë‹¤ë§Œ subscriptëŠ” ì „ì²´ structë¥¼ ì•”ë¬µì ìœ¼ë¡œ ì ‘ê·¼í•˜ë¯€ë¡œ, ë‹¤ìŒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤:

```swift
var x: ArrayLikeType
swap(&x[0], &x[1]) // ğŸ›‘ ë‘ ê°œì˜ mutating access
```

---

## **í˜¸í™˜ì„±**

### **Source compatibility**

ê¸°ì¡´ì— `borrow`ë‚˜ `mutate`ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ trailing closureë¡œ í˜¸ì¶œí•˜ëŠ” ê²½ìš°ì™€ ì¶©ëŒ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.

```swift
struct S {
  func borrow(closure: () -> ()) { ... }
  // Is this a new borrow accessor?
  // Or a call to the borrow method just above?
  var property: Int { borrow { ... } }
}
```

í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ê±°ì˜ ë°œìƒí•˜ì§€ ì•Šì„ ê²ƒìœ¼ë¡œ ë´…ë‹ˆë‹¤.

### **ABI compatibility**

ìƒˆë¡œìš´ ê¸°ëŠ¥ì´ë¼ ê¸°ì¡´ ABIì—ëŠ” ì˜í–¥ì´ ì—†ìŠµë‹ˆë‹¤.

### **Adoption ì˜í–¥**

Non-borrowing accessorë¥¼ borrowing accessorë¡œ ë°”ê¾¸ëŠ” ê±´ ì¼ë°˜ì ìœ¼ë¡œ **ABI-breaking**ì…ë‹ˆë‹¤.

í•˜ì§€ë§Œ existential typeì˜ ABIëŠ” ë³´ì¡´ë©ë‹ˆë‹¤ (ì»´íŒŒì¼ëŸ¬ê°€ ê³„ì† accessorë¥¼ í•©ì„±í•  ìˆ˜ ìˆë‹¤ë©´).

Source-breakingì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ `get`ì„ `borrow`ë¡œ ë°”ê¾¸ë©´ lifetime ì œì•½ì´ ìƒê²¨ì„œ ê¸°ì¡´ ì½”ë“œê°€ ì»´íŒŒì¼ë˜ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.

---

## **í–¥í›„ ë°©í–¥**

### **Borrowing returns**

í•¨ìˆ˜ì—ì„œë„ borrowed ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìœ¼ë©´ ìœ ìš©í•©ë‹ˆë‹¤.

```swift
struct S<Value> {
  subscript(_ index: Int) -> Value {
     borrow { ... }
  }
  func indirect(_ parameter: Foo) -> borrowing Value {
     let index = ... compute index from parameter ...
     return self[index]
  }
}
```

### **Unsafe pointerë¥¼ í†µí•œ borrowing**

ì €ìˆ˜ì¤€ ë°ì´í„° êµ¬ì¡°ëŠ” ì¢…ì¢… unsafe pointerë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

```swift
var _storage: UnsafePointer<Element>

var first: Element {
  borrow {
    // ERROR: borrow accessors can only return stored properties
    // or computed properties that have borrow accessors
    return _storage.pointee
  }
}
```

ì´ëŸ° ì¼€ì´ìŠ¤ë¥¼ ì§€ì›í•˜ë ¤ë©´ ë­”ê°€ annotationì´ í•„ìš”í•  ê²ƒ ê°™ìŠµë‹ˆë‹¤.

```swift
var first: Element {
  borrow {
    return unsafeResultDependsOnSelf(_storage.pointee)
  }
}
```

---

## **ëŒ€ì•ˆë“¤**

### **ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê¸°?**

Yielding coroutine-based accessorë„ ë¹„ìŠ·í•œ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ, ì„±ëŠ¥ íŠ¹ì„±ì´ ë‹¤ë¦…ë‹ˆë‹¤.

Coroutine accessorëŠ” ì ‘ê·¼ í›„ì— ì½”ë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆì–´ì„œ ì˜ë¯¸ë¡ ì ìœ¼ë¡œëŠ” ë” ê°•ë ¥í•˜ì§€ë§Œ, ì™„ì „íˆ inlineë˜ì§€ ì•Šìœ¼ë©´ ì—¬ëŸ¬ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œê°€ ìˆìŠµë‹ˆë‹¤.

> Borrowing accessorëŠ” ì—¬ëŸ¬ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì—†ì´ in-place mutation ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

---

## **Conclusion**

í˜„ì¬ SE-0507ì€ 2026ë…„ 2ì›” 9ì¼ê¹Œì§€ ë¦¬ë·°ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.

ê°œì¸ì ìœ¼ë¡œëŠ” ì •ë§ í¥ë¯¸ë¡œìš´ ì œì•ˆì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.

íŠ¹íˆ non-copyable íƒ€ì…ì„ ë‹¤ë£¨ëŠ” collectionì´ë‚˜ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ì €ìˆ˜ì¤€ ì½”ë“œì—ì„œ í° ë„ì›€ì´ ë  ê²ƒ ê°™ì•„ìš”.

`get`ì˜ ë³µì‚¬ ì˜¤ë²„í—¤ë“œì™€ yielding accessorì˜ coroutine ì˜¤ë²„í—¤ë“œ ì‚¬ì´ì˜ sweet spotì„ ì°¾ì€ ëŠë‚Œì…ë‹ˆë‹¤.

Swift Standard Library íŒ€ì—ì„œë„ ì´ ê¸°ëŠ¥ì„ ì›í–ˆë‹¤ê³  í•˜ë‹ˆ, ì‹¤ë¬´ì—ì„œ ì •ë§ í•„ìš”í•œ ê¸°ëŠ¥ì¸ ê²ƒ ê°™ë„¤ìš” ğŸ˜ƒ

---

## **References**

[swift-evolution/proposals/0507-borrow-accessors.md at main Â· swiftlang/swift-evolution](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0507-borrow-accessors.md)

[Pitch: Borrowing Accessors - Swift Forums](https://forums.swift.org/t/pitch-borrowing-accessors/83933)

[SE-0507: Borrow and Mutate Accessors - Swift Forums](https://forums.swift.org/t/se-0507-borrow-and-mutate-accessors/84376)

[Prospective Vision: Accessors - Swift Forums](https://forums.swift.org/t/prospective-vision-accessors/76707)
